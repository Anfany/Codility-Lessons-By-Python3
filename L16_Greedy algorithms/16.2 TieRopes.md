# Lesson_16 Greedy algorithms  

### P16.2 [TieRopes](https://app.codility.com/programmers/lessons/16-greedy_algorithms/tie_ropes/) 

###### Tie adjacent ropes to achieve the maximum number of ropes of length >= K.

* #### P16.2 系绳索

#####  通过系紧相邻的绳索，计算使得绳索长度不小于K的绳索数最多

地板上有N条绳索，编号从0到N-1，其长度在数组A中给出，编号为I(0 ≤ I < N)的绳索的长度为A[I]。

编号相邻(I和I+1为相邻编号)的两条绳索可以系在一起形成新的绳索，而形成的绳索的长度是两条绳索的长度之和，新的绳索同样也可以和相邻的绳索系在一起。

对于给定的整数K，目标是计算使得绳索长度不小于K的绳索数最大。

例如，考虑K=4和数组A：

A[0]=1，A[1]=2，A[2]=3，A[3]=4，A[4]=1，A[5]=1，A[6]=3

绳索如下图所示。

![image](https://github.com/Anfany/Codility-Lessons-By-Python3/blob/master/L16_Greedy%20algorithms/16.2.1.png)

通过以下操作：

  1. 绳索1和2系在一起，产生了长度为A[1]+A[2]=5的新绳索；
  2. 绳索4、5和6系在一起，产生了长度为A[4]+A[5]+A[6]=5的新绳索。
 
![image](https://github.com/Anfany/Codility-Lessons-By-Python3/blob/master/L16_Greedy%20algorithms/16.2.2.png) 
  
此时，有3根长度不小于K=4的绳索(蓝框中显示)。不管如何操作，也不可能产生4根这样的绳索。

编写函数：
```
def solution(K, A)
```

给定整数K和N个整数的非空数组A，则返回可以得到的长度不小于K的绳索数的最大值。

例如，针对上面的例子，函数应该返回3。


假定：
  1. N是区间[1，100,000]内的整数；
  2. K是区间[1，1,000,000,000]内的整数；
  3. 数组A的每个元素都是区间[1，1,000,000,000]内的整数；

* #### 解题思路


* #### Python3代码


```


```




* #### 结果


![image](https://github.com/Anfany/Codility-Lessons-By-Python3/blob/master/L16_Greedy%20algorithms/16.2.png)
