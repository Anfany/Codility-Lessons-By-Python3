# Lesson_14 Binary search algorithm  

### P14.1 [NailingPlanks](https://app.codility.com/programmers/lessons/14-binary_search_algorithm/nailing_planks/) 



###### Count the minimum number of nails that allow a series of planks to be nailed.


* #### P14.1  钉木板

##### 计算钉牢所有木板需要的钉子的最小数量

两个非空数组A和B，均由N个整数组成，这些数组表示N个木板。更准确地说，A[K]是第K个木板的起点，B[K]是终点。

一个由M个整数组成的非空数组C，这个数组表示M个钉子。更准确地说，C[I]是可以钉入第I个钉子的位置。

如果存在钉子c[I]，对于任意的K，只要满足A[K] ≤ C[I] ≤ B[K]，就表示木板(A[K], B[K])可以被钉牢。

目标是找到使得所有木板都被钉牢，所使用的最小钉子数量。换句话说，应该找到一个值J，这样在只使用前J个钉子之后所有木板都被钉牢了。也就是说，对于每一块木板(A[K], B[K])，其中0 ≤ K < N，应该存在一个钉子C[I] ，使得I < J和A[K] ≤ C[I] ≤ B[K]成立。

例如，给定的数组A、B：

A[0]=1，A[1]=4，A[2]=5，A[3]=8；

B[0]=4，B[1]=5，B[2]=9，B[3]=10

四块木板分别为[1，4]、[4，5]、[5，9]和[8，10]。

给定的数组C：

C[0]=4，C[1]=6，C[2]=7，C[3]=10，C[4]=2

使用以下钉子：

  1. 使用第1个钉子：[1，4]和[4，5]都被钉牢：因为1<=4<=4，4<=4<=5。
  2. 使用前2个钉子：木板[1，4]，[4，5]和[5，9]被钉牢。
  3. 使用前3个钉子：木板[1、4]、[4、5]和[5、9]被钉牢， 
  4. 使用前4个钉子：所有的木板都将被钉牢。

因此，4个是使用的最小钉子数量，可以钉牢所有木板。

编写函数：
```
def solution(A, B, C)
```
给定两个由N个整数组成的非空数组A和B,一个由M个整数组成的非空数组C，则返回钉牢所有木板需要使用的最小的钉子数量。如果无法钉牢所有木板，函数应返回-1。

例如，针对上面的例子，函数应返回4。

假定：
1. N和M是区间[1，30000]内的整数；
2. 数组A、B、C的每个元素都是区间[1，2\*M]内的整数；
3. A[K] ≤ B[K]； 

* #### 解题思路




* #### Python3代码

```


```


* #### 结果

![image](https://github.com/Anfany/Codility-Lessons-By-Python3/blob/master/L14_Binary%20search%20algorithm/14.1.png)
