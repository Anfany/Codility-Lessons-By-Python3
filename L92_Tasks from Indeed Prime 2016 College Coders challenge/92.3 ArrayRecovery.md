## Lesson_92 Tasks from Indeed Prime 2016 College Coders challenge


### P92.3 [ArrayRecovery](https://app.codility.com/programmers/lessons/92-tasks_from_indeed_prime_2016_college_coders_challenge/array_recovery/) 


###### Recover a broken array using partial information in another array.

* #### P92.3 还原数组

##### 根据一个数组，还原另一个数组

数组A，有N个元素。每个元素都是不超过M的**正**整数。

Bob编写了一个程序来获得数组B，定义如下：对于每个索引J，寻找使得K < J和A[K] < A[J]成立的最大的K。然后令B[J] = A[K]。如果不存在这样的K，那么令B[J]=0。也就是说，数组B的索引为J的元素就是数组A中，索引小于J的，最后一个出现的小于A[J]的值，如果没有这样的元素，则为0。

例如， A=[2，5，3，7，9，6]，可得B＝[0，2，2，3，7，3]。例如，B[5]=3，因为A[5]是6，而A[5]之前小于6的最后一个值是3。

Bob得到了数组B，但是却误删了A。他现在打算找到可以生成B的所有可能的A的个数。由于个数可能很大，返回mod(10^9+7)

编写函数：
```python
def solution(B, M)
```

给定一个整数M和一个具有N个整数的数组B，则返回能生成数组B的所有的A的个数被10^9+7除得到的余数。至少存在一个A，可以生成数组B。

例如，给定：M=4，B=[0，2，2]，函数应返回3。数组A可以是：[2，3，3]，[2，4，3]或[2，4，4]。

给定：M=10，B=[0，3，5，6]，函数应返回4，数组A可以是：[3，5，6，7]，[3，5，6，8]，[3，5，6，9]或[3，5，6，10]。

给定：M=10^5，B=[0，0]，则A有5000050000个可能（数组A中的第一个元素可以是[1-10^5]区间内的任何数，第二个元素可以等于或小于第一个元素），因此函数应返回49965（取mod(10^9+7)之后）。

假定：
  1. N是区间[1，100,000]内的整数；
  2. M是区间[1，1,000,000,000]内的整数；
  3. 数组B的每个元素都是区间[0，M]内的整数；
  4. 能生成数组B的数组A的个数至少为1；


* #### 解题思路

假如有m个位置，每个位置数字的取值均为[1,n]，并且后面的数小于等于前面的数，满足这样条件的所有的组合**CountA**，可以根据下面的式子得到：

<a href="https://www.codecogs.com/eqnedit.php?latex={\color{DarkRed}&space;\mathbf{CountA=C(n-1+m,&space;m)}=&space;\mathbf{\frac{(n&space;-&space;1&space;&plus;&space;m)\mathbf{!}}{(n&space;-1)\mathbf{!}&space;*&space;m&space;\mathbf{!}}}}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?{\color{DarkRed}&space;\mathbf{CountA=C(n-1+m,&space;m)}=&space;\mathbf{\frac{(n&space;-&space;1&space;&plus;&space;m)\mathbf{!}}{(n&space;-1)\mathbf{!}&space;*&space;m&space;\mathbf{!}}}}" title="{\color{DarkRed} \mathbf{CountA=C(n-1+m, m)}= \mathbf{\frac{(n - 1 + m)\mathbf{!}}{(n -1)\mathbf{!} * m \mathbf{!}}}}" /></a>

其中n代表某个位置上可以选择的数字的个数，m表示有多少个这样连续的位置。

对于该问题，下面几点说明需要知晓：

   1. B中某个位置开始持续出现同一个数字，这些位置上数字的取值范围是一样的，只不过后面的数字不大于前面的数字，因此这些位置上的数字的可能性就可根据上面式子得出。
   
   2. 对于B中某个位置的数字而言，如果后面的数字小于它，则这个位置的取值和后面是没有关系的，并且这个数字肯定以前就出现过。如果大于它，说明这个位置只有一种可能性，那就是等于后面的数字；
  
下面分情况讨论：
 
   + **1，B的元素均为0，此时A有M种可能：CountA=M；**
   
   + **2，B不存在相同的元素，此时只有A的最后一个元素有多种可能：CountA=M - B[-1]；**
   
   + **3，开始分情况考虑，具体参见程序注释；
         
         

* #### Python3代码

```python



```

* #### 结果



![image](https://github.com/Anfany/Codility-Lessons-By-Python3/blob/master/L92_Tasks%20from%20Indeed%20Prime%202016%20College%20Coders%20challenge/92.3.png)
