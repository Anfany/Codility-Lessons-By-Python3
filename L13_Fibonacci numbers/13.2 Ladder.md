# Lesson_13 Fibonacci numbers  


### P13.2 [Ladder](https://app.codility.com/programmers/lessons/13-fibonacci_numbers/ladder/) 

###### Count the number of different ways of climbing to the top of a ladder.

* #### P13.2 爬梯方法

##### 计算爬到梯子顶端的不同方式的个数

梯子有N个横档，编号从1到N。每爬一步，可以上升一或者2个横档。也就是说：如果在编号为K的横档上，爬一步可以到K+1或K+2横档上。爬行第一步后，可以到达
编号为1或者编号为2的横档上，但是最终需要站到编号为N的横档上(梯子的顶端)。

计算爬到梯子顶端的不同方式的数量。

例如，如果N=4，则有5种不同的攀爬方式，分别是：

  (1) 1、1、1和1级：每一步都上1个；
  
  (2) 1、1和2级：前2步上1个，最后一步上2个；
  
  (3) 1、2和1级：第一步上1个，第二步上2个，第三步上1个；
  
  (4) 2、1和1级：第一步上2个，最后两步上1个；
  
  (5) 2和2个梯级：每一步都上2个；

如果N=5，你有8种不同的攀爬方式，分别是：

  (1) 1、1、1、1和1级；
  
  (2) 1、1、1和2级；
  
  (3) 1、1、2和1级；
  
  (4) 1、2、1和1级；
  
  (5) 1、2和2级；
  
  (6) 2、1、1和1级；
  
  (7) 2、1和2级；
  
  (8) 2、2和1级；
  
不同方法的数目可能非常大，因此对于给定的整数P，返回**mod**2P的值。

编写函数：
```
def solution(A, B)
```

给定两个由L的整数组成的非空数组A和B，则同样返回一个长度为L的数组，该数组的位置i上的元素为：爬到横档数为A[i]的梯子的顶部的所有方法的个数**mod**
2B[i]的值。

例如，给定L=5和：

A[0]=4，A[1]=4，A[2]=5，A[3]=5，A[4]=1；B[0]=3，B[1]=2，B[2]=4，B[3]=3，B[4]=1

函数应该返回序列[5，1，8，0，1]。

假定：

  1. L是区间[1，50000]中的整数；
  2. 数组A的每个元素都是区间[1，L]内的整数；
  3. 数组B的每个元素都是区间[1，30]内的整数；
  
* #### 解题思路


* #### Python3代码

```




```

* #### 结果


![image](https://github.com/Anfany/Codility-Lessons-By-Python3/blob/master/L13_Fibonacci%20numbers/13.2.png)
